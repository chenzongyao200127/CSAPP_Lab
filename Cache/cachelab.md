# Cache Lab: Understanding Cache Memories

## 1 Logistics
This is an individual project. You must run this lab on a 64-bit x86-64 machine.
SITE-SPECIFIC: Insert any other logistical items here, such as how to ask for help.

## 2 Overview
This lab will help you understand the impact that cache memories can have on the performance of your C programs.
The lab consists of two parts. 
- In the first part you will write a small C program (about 200-300 lines) that simulates the behavior of a cache memory. 
- In the second part, you will optimize a small matrix transpose function, with the goal of minimizing the number of cache misses

## 3 Downloading the assignment

Start by copying cachelab-handout.tar to a protected Linux directory in which you plan to do your work. Then give the command

linux> tar xvf cachelab-handout.tar

This will create a directory called cachelab-handout that contains a number of files. You will be modifying two files: csim.c and trans.c. To compile these files, type:

linux> make clean
linux> make

WARNING: Do not let the Windows WinZip program open up your .tar file (many Web browsers are set to do this automatically). 
Instead, save the file to your Linux directory and use the Linux tar program to extract the files. 
In general, for this class you should NEVER use any platform other than Linux to modify your files. Doing so can cause loss of data (and important work!).

## 4 Description

The lab has two parts. In Part A you will implement a cache simulator. In Part B you will write a matrix transpose function that is optimized for cache performance.

### 4.1 Reference Trace Files
The traces subdirectory of the handout directory contains a collection of reference trace files that we will use to evaluate the correctness of the cache simulator you write in Part A. The trace files are generated by a Linux program called valgrind. For example, typing

linux> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l

on the command line runs the executable program “ls -l”, captures a trace of each of its memory accesses in the order they occur, and prints them on stdout.

Valgrind memory traces have the following form:
I 0400d7d4,8
    M 0421c7f0,4
    L 04f6b868,8
    S 7ff0005c8,8

Each line denotes one or two memory accesses. The format of each line is

 [space]operation address,size

The operation field denotes the type of memory access: 
 - “I” denotes an instruction load
 - “L” a data load,
 - “S” a data store,
 - “M” a data modify (i.e., a data load followed by a data store). 
There is never a space before each “I”. There is always a space before each “M”, “L”, and “S”. The address field specifies a 64-bit hexadecimal memory address. The size field specifies the number of bytes accessed by the operation.

发放目录中的 traces 子目录包含一系列参考跟踪文件，我们将使用这些文件来评估你在第 A 部分编写的缓存模拟器的正确性。
这些跟踪文件是由一个名为 valgrind 的 Linux 程序生成的。例如，在命令行输入

linux> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l

会运行可执行程序 “ls -l”，捕获其内存访问的跟踪，并按发生顺序将它们打印到标准输出上。

Valgrind 内存跟踪的格式如下：
I 0400d7d4,8
  M 0421c7f0,4
  L 04f6b868,8
  S 7ff0005c8,8

每行表示一个或两个内存访问。每行的格式为

 [空格]操作 地址,大小

操作字段表示内存访问的类型：
 - “I” 表示指令加载
 - “L” 表示数据加载
 - “S” 表示数据存储
 - “M” 表示数据修改（即数据加载后跟数据存储）。
  
每个 “I” 前面从不有空格。每个 “M”、“L” 和 “S” 前面总是有一个空格。
地址字段指定了一个 64 位的十六进制内存地址。大小字段指定操作访问的字节数。

### 4.2 Part A: Writing a Cache Simulator

In Part A you will write a cache simulator in csim.c that takes a valgrind memory trace as input, simulates the hit/miss behavior of a cache memory on this trace, and outputs the total number of hits, misses, and evictions.

We have provided you with the binary executable of a reference cache simulator, called csim-ref, that simulates the behavior of a cache with arbitrary size and associativity on a valgrind trace file. It uses the LRU (least-recently used) replacement policy when choosing which cache line to evict.

The reference simulator takes the following command-line arguments:

Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>
• -h: Optional help flag that prints usage info
• -v: Optional verbose flag that displays trace info
• -s <s>: Number of set index bits (S = 2^s is the number of sets)
• -E <E>: Associativity (number of lines per set)
• -b <b>: Number of block bits (B = 2^b is the block size)
• -t <tracefile>: Name of the valgrind trace to replay

The command-line arguments are based on the notation (s, E, and b) from page 597 of the CS:APP2e textbook. For example:

linux> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace
hits:4 misses:5 evictions:3

The same example in verbose mode:

linux> ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace
L 10,1 miss
M 20,1 miss hit
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3

Your job for Part A is to fill in the csim.c file so that it takes the same command line arguments and produces the identical output as the reference simulator. Notice that this file is almost completely empty. You’ll need to write it from scratch.

在第 A 部分，你将在 csim.c 中编写一个缓存模拟器，它接受 Valgrind 内存跟踪作为输入，模拟一个缓存在此跟踪上的命中/未命中行为，并输出总的命中次数、未命中次数和驱逐次数。

我们为你提供了一个参考缓存模拟器的二进制可执行文件，名为 csim-ref，它能模拟在 Valgrind 跟踪文件上任意大小和关联性的缓存的行为。
当选择要驱逐哪个缓存行时，它使用最近最少使用（LRU）替换策略。

参考模拟器接受以下命令行参数：

用法：./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>
• -h：可选的帮助标志，打印使用信息
• -v：可选的详细标志，显示跟踪信息
• -s <s>：设置索引位的数量（S = 2^s 是集合的数量）
• -E <E>：关联性（每组的行数）
• -b <b>：块位的数量（B = 2^b 是块的大小）
• -t <tracefile>：Valgrind 跟踪文件的名称，用于回放

命令行参数基于 CS:APP2e 教科书第 597 页的符号（s、E 和 b）。例如：

~~~shell
linux> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace
hits:4 misses:5 evictions:3
~~~

相同示例的详细模式：

~~~shell
linux> ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace
L 10,1 miss
M 20,1 miss hit
L 22,1 hit
S 18,1 hit
L 110,1 miss eviction
L 210,1 miss eviction
M 12,1 miss eviction hit
hits:4 misses:5 evictions:3
~~~

*你在第 A 部分的任务是填写 csim.c 文件，使其接受相同的命令行参数并产生与参考模拟器相同的输出。注意，这个文件几乎是完全空的。你需要从头开始编写它*

### Programming Rules for Part A
- Include your name and loginID in the header comment for csim.c.

- Your csim.c file must compile without warnings in order to receive credit.
  
- Your simulator must work correctly for arbitrary s, E, and b. This means that you will need to allocate storage for your simulator’s data structures using the malloc function. Type “man malloc” for information about this function.

- For this lab, we are interested only in data cache performance, so your simulator should ignore all instruction cache accesses (lines starting with “I”). Recall that valgrind always puts “I” in the first column (with no preceding space), and “M”, “L”, and “S” in the second column (with a preceding space). This may help you parse the trace.

- To receive credit for Part A, you must call the function printSummary, with the total number of hits, misses, and evictions, at the end of your main function:
printSummary(hit_count, miss_count, eviction_count);

- For this this lab, you should assume that memory accesses are aligned properly, such that a single memory access never crosses block boundaries. By making this assumption, you can ignore the request sizes in the valgrind traces.

- 在 csim.c 的头部注释中包含你的姓名和登录 ID。
- 你的 csim.c 文件必须在编译时无警告，以获得学分。
- 你的模拟器必须能够正确处理任意的 s（组索引的位数）、E（每组中行的数量）和 b（块大小的位数）。这意味着你需要使用 malloc 函数为模拟器的数据结构分配存储空间。输入 “man malloc” 获取关于这个函数的信息。
- 在此实验中，我们只关注数据缓存性能，因此你的模拟器应忽略所有指令缓存访问（以 “I” 开头的行）。请记住，valgrind 始终在第一列（没有前导空格）放置 “I”，并在第二列（有前导空格）放置 “M”，“L” 和 “S”。这可以帮助你解析跟踪记录。
- 为了获得第 A 部分的学分，你必须在 main 函数的末尾调用函数 printSummary，并传入总的命中次数、未命中次数和驱逐次数：
  `printSummary(hit_count, miss_count, eviction_count)`;
- 在此实验中，你应该假设内存访问是正确对齐的，因此单个内存访问永远不会跨越块边界。通过做出这个假设，你可以忽略 valgrind 跟踪中的请求大小。

### 4.3 Part B: Optimizing Matrix Transpose

In Part B you will write a transpose function in trans.c that causes as few cache misses as possible.

Let A denote a matrix, and A[ij] denote the component on the ith row and jth column. The transpose of A, denoted AT , is a matrix such that A[ij] = AT
[ji].

To help you get started, we have given you an example transpose function in trans.c that computes the transpose of N × M matrix A and stores the results in M × N matrix B:
~~~c
char trans_desc[] = "Simple row-wise scan transpose";
void trans(int M, int N, int A[N][M], int B[M][N])
~~~
The example transpose function is correct, but it is inefficient because the access pattern results in relatively many cache misses.
Your job in Part B is to write a similar function, called transpose_submit, that minimizes the number of cache misses across different sized matrices:
~~~c
char transpose_submit_desc[] = "Transpose submission";
void transpose_submit(int M, int N, int A[N][M], int B[M][N]);
~~~
Do not change the description string (“Transpose submission”) for your transpose_submit function. The autograder searches for this string to determine which transpose function to evaluate for credit

在第 B 部分，你将在 trans.c 中编写一个转置函数，该函数能尽可能减少缓存未命中次数。

假设 A 为一个矩阵，A[ij] 表示第 i 行第 j 列的元素。A 的转置，记为 AT，是一个矩阵，满足 A[ij] = AT[ji]。

为了帮助你开始，我们在 trans.c 中提供了一个示例转置函数，它计算 N × M 矩阵 A 的转置，并将结果存储在 M × N 矩阵 B 中：

```c
char trans_desc[] = "Simple row-wise scan transpose";
void trans(int M, int N, int A[N][M], int B[M][N])
```

示例转置函数是正确的，但它效率低下，因为访问模式导致了相对较多的缓存未命中。
你在第 B 部分的任务是编写一个类似的函数，名为 transpose_submit，该函数最小化不同大小矩阵上的缓存未命中次数：

```c
char transpose_submit_desc[] = "Transpose submission";
void transpose_submit(int M, int N, int A[N][M], int B[M][N]);
```

不要更改你的 transpose_submit 函数的描述字符串（“Transpose submission”）。自动评分系统会搜索这个字符串来确定哪个转置函数用于评分。

### Programming Rules for Part B
- Include your name and loginID in the header comment for trans.c.
- Your code in trans.c must compile without warnings to receive credit.
- You are allowed to define at most 12 local variables of type int per transpose function.1
- You are not allowed to side-step the previous rule by using any variables of type long or by using any bit tricks to store more than one value to a single variable.
- Your transpose function may not use recursion.
- If you choose to use helper functions, you may not have more than 12 local variables on the stack at a time between your helper functions and your top level transpose function. For example, if your transpose declares 8 variables, and then you call a function which uses 4 variables, which calls another function which uses 2, you will have 14 variables on the stack, and you will be in violation of the rule.
- Your transpose function may not modify array A. You may, however, do whatever you want with the contents of array B.
- You are NOT allowed to define any arrays in your code or to use any variant of malloc.

- 在 trans.c 的头部注释中包含你的姓名和登录 ID。
- trans.c 中的代码必须在编译时无警告才能获得学分。
- 每个转置函数最多只能定义 12 个类型为 int 的局部变量。
- 不允许使用任何类型为 long 的变量或使用任何位技巧来存储多于一个值到单个变量，以规避上述规则。
- 你的转置函数不能使用递归。
- 如果你选择使用辅助函数，你的辅助函数和顶层转置函数之间在任何时候栈上的局部变量总数不得超过 12 个。例如，如果你的转置函数声明了 8 个变量，然后你调用一个使用 4 个变量的函数，该函数又调用了一个使用 2 个变量的函数，那么你将在栈上有 14 个变量，这将违反规则。
- 你的转置函数不得修改数组 A。但是，你可以随意操作数组 B 的内容。
- 你不允许在代码中定义任何数组，也不允许使用 malloc 或其变体。

## Evaluation
This section describes how your work will be evaluated. The full score for this lab is 60 points:
• Part A: 27 Points
• Part B: 26 Points
• Style: 7 Points

### 5.1 Evaluation for Part A
For Part A, we will run your cache simulator using different cache parameters and traces. There are eight test cases, each worth 3 points, except for the last case, which is worth 6 points:
    linux> ./csim -s 1 -E 1 -b 1 -t traces/yi2.trace
    linux> ./csim -s 4 -E 2 -b 4 -t traces/yi.trace
    linux> ./csim -s 2 -E 1 -b 4 -t traces/dave.trace
    linux> ./csim -s 2 -E 1 -b 3 -t traces/trans.trace
    linux> ./csim -s 2 -E 2 -b 3 -t traces/trans.trace
    linux> ./csim -s 2 -E 4 -b 3 -t traces/trans.trace
    linux> ./csim -s 5 -E 1 -b 5 -t traces/trans.trace
    linux> ./csim -s 5 -E 1 -b 5 -t traces/long.trace

You can use the reference simulator `csim-ref` to obtain the correct answer for each of these test cases. During debugging, use the -v option for a detailed record of each hit and miss. 

For each test case, outputting the correct number of cache hits, misses and evictions will give you full credit for that test case. Each of your reported number of hits, misses and evictions is worth 1/3 of the credit for that test case. That is, if a particular test case is worth 3 points, and your simulator outputs the correct number of hits and misses, but reports the wrong number of evictions, then you will earn 2 points.

对于第 A 部分，我们将使用不同的缓存参数和跟踪来运行你的缓存模拟器。共有八个测试用例，每个测试用例值 3 分，除了最后一个用例，它值 6 分：
    linux> ./csim -s 1 -E 1 -b 1 -t traces/yi2.trace
    linux> ./csim -s 4 -E 2 -b 4 -t traces/yi.trace
    linux> ./csim -s 2 -E 1 -b 4 -t traces/dave.trace
    linux> ./csim -s 2 -E 1 -b 3 -t traces/trans.trace
    linux> ./csim -s 2 -E 2 -b 3 -t traces/trans.trace
    linux> ./csim -s 2 -E 4 -b 3 -t traces/trans.trace
    linux> ./csim -s 5 -E 1 -b 5 -t traces/trans.trace
    linux> ./csim -s 5 -E 1 -b 5 -t traces/long.trace

你可以使用参考模拟器 `csim-ref` 来获取每个测试用例的正确答案。在调试时，使用 -v 选项可以详细记录每次命中和未命中。

对于每个测试用例，输出正确的缓存命中数、未命中数和驱逐数将使你获得该测试用例的全部分数。你报告的每个命中数、未命中数和驱逐数值 1/3 的该测试用例分数。也就是说，如果一个特定的测试用例值 3 分，而你的模拟器输出了正确的命中数和未命中数，但报告了错误的驱逐数，那么你将获得 2 分。

### 5.2 Evaluation for Part B
For Part B, we will evaluate the correctness and performance of your transpose_submit function on three different-sized output matrices:
• 32 × 32 (M = 32, N = 32)
• 64 × 64 (M = 64, N = 64)
• 61 × 67 (M = 61, N = 67)

### 5.2.1 Performance (26 pts)
For each matrix size, the performance of your transpose_submit function is evaluated by using valgrind to extract the address trace for your function, and then using the reference simulator to replay this trace on a cache with parameters (s = 5, E = 1, b = 5).

Your performance score for each matrix size scales linearly with the number of misses, m, up to some threshold:
• 32 × 32: 8 points if m < 300, 0 points if m > 600
• 64 × 64: 8 points if m < 1, 300, 0 points if m > 2, 000
• 61 × 67: 10 points if m < 2, 000, 0 points if m > 3, 000

Your code must be correct to receive any performance points for a particular size. Your code only needs to be correct for these three cases and you can optimize it specifically for these three cases. 

In particular, it is perfectly OK for your function to explicitly check for the input sizes and implement separate code optimized for each case.


### 5.3 Evaluation for Style
There are 7 points for coding style. These will be assigned manually by the course staff.  
Style guidelines can be found on the course website. 
The course staff will inspect your code in Part B for illegal arrays and excessive local variables.


## 6 Working on the Lab

### 6.1 Working on Part A

We have provided you with an autograding program, called `test-csim`, that tests the correctness of your cache simulator on the reference traces. Be sure to compile your simulator before running the test:

~~~shell
linux> make
linux> ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     0 (1,1,1)       0       0       0       9       8       6  traces/yi2.trace
     0 (4,2,4)       0       0       0       4       5       2  traces/yi.trace
     0 (2,1,4)       0       0       0       2       3       1  traces/dave.trace
     0 (2,1,3)       0       0       0     167      71      67  traces/trans.trace
     0 (2,2,3)       0       0       0     201      37      29  traces/trans.trace
     0 (2,4,3)       0       0       0     212      26      10  traces/trans.trace
     1 (5,1,5)       0       0       0     231       7       0  traces/trans.trace
     0 (5,1,5)       0       0       0  265189   21775   21743  traces/long.trace
     1
~~~

For each test, it shows the number of points you earned, the cache parameters, the input trace file, and a comparison of the results from your simulator and the reference simulator.

Here are some hints and suggestions for working on Part A:

- Do your initial debugging on the small traces, such as traces/dave.trace
- The reference simulator takes an optional -v argument that enables verbose output, displaying the hits, misses, and evictions that occur as a result of each memory access. You are not required to implement this feature in your csim.c code, but we strongly recommend that you do so. It will help you debug by allowing you to directly compare the behavior of your simulator with the reference simulator on the reference trace files.
- We recommend that you use the getopt function to parse your command line arguments. You’ll need the following header files:
~~~c
#include <getopt.h>
#include <stdlib.h>
#include <unistd.h>
~~~
See “man 3 getopt” for details

- Each data load (L) or store (S) operation can cause at most one cache miss. The data modify operation (M) is treated as a load followed by a store to the same address. Thus, an M operation can result in two cache hits, or a miss and a hit plus a possible eviction
- If you would like to use C0-style contracts from 15-122, you can include contracts.h, which we have provided in the handout directory for your convenience.

- 在小型跟踪记录上进行初步调试，例如使用 traces/dave.trace。
- 参考模拟器接受一个可选的 -v 参数，该参数启用详细输出，显示由每次内存访问引起的命中、未命中和驱逐。你不需要在你的 csim.c 代码中实现这个功能，但我们强烈建议你这样做。通过允许你直接比较你的模拟器与参考模拟器在参考跟踪文件上的行为，这将帮助你进行调试。
- 我们建议你使用 getopt 函数来解析命令行参数。你需要以下头文件：
  ```c
  #include <getopt.h>
  #include <stdlib.h>
  #include <unistd.h>
  ```
  有关详细信息，请参阅 “man 3 getopt”。

- 每个数据加载（L）或存储（S）操作最多可导致一次缓存未命中。数据修改操作（M）被视为先加载后存储到同一地址。因此，一个 M 操作可能导致两次缓存命中，或一次未命中和一次命中加上可能的驱逐。
- 如果你想使用来自 15-122 的 C0 风格契约，你可以包含我们在发放目录中为你方便提供的 contracts.h。


## 6.2 Working on Part B

We have provided you with an autograding program, called test-trans.c, that tests the correctness and performance of each of the transpose functions that you have registered with the autograder.

You can register up to 100 versions of the transpose function in your trans.c file. Each transpose version has the following form:

~~~c
/* Header comment */
char trans_simple_desc[] = "A simple transpose";
void trans_simple(int M, int N, int A[N][M], int B[M][N])
{
/* your transpose code here */
}
~~~

Register a particular transpose function with the autograder by making a call of the form:

~~~c
registerTransFunction(trans_simple, trans_simple_desc);
~~~

in the registerFunctions routine in trans.c. At runtime, the autograder will evaluate each registered transpose function and print the results. Of course, one of the registered functions must be the transpose_submit function that you are submitting for credit:
~~~c
registerTransFunction(transpose_submit, transpose_submit_desc);
~~~

See the default trans.c function for an example of how this works.

The autograder takes the matrix size as input. It uses valgrind to generate a trace of each registered transpose function. It then evaluates each trace by running the reference simulator on a cache with parameters
(s = 5, E = 1, b = 5).

For example, to test your registered transpose functions on a 32 × 32 matrix, rebuild test-trans, and then run it with the appropriate values for M and N :

~~~shell
  linux> make
  linux> ./test-trans -M 32 -N 32
  Step 1: Evaluating registered transpose funcs for correctness:
  func 0 (Transpose submission): correctness: 1
  func 1 (Simple row-wise scan transpose): correctness: 1
  func 2 (column-wise scan transpose): correctness: 1
  func 3 (using a zig-zag access pattern): correctness: 1
  Step 2: Generating memory traces for registered transpose funcs.
  Step 3: Evaluating performance of registered transpose funcs (s=5, E=1, b=5)
  func 0 (Transpose submission): hits:1766, misses:287, evictions:255
  func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151
  func 2 (column-wise scan transpose): hits:870, misses:1183, evictions:1151
  func 3 (using a zig-zag access pattern): hits:1076, misses:977, evictions:945
  Summary for official submission (func 0): correctness=1 misses=287
~~~

In this example, we have registered four different transpose functions in trans.c. The test-trans program tests each of the registered functions, displays the results for each, and extracts the results for the official submission.

Here are some hints and suggestions for working on Part B.
 - The test-trans program saves the trace for function i in file trace.fi.2 These trace files are invaluable debugging tools that can help you understand exactly where the hits and misses for each
 - transpose function are coming from. To debug a particular function, simply run its trace through the reference simulator with the verbose option:

    linux> ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0
    S 68312c,1 miss
    L 683140,8 miss
    L 683124,4 hit
    L 683120,4 hit
    L 603124,4 miss eviction
    S 6431a0,4 miss
    ...

 - Since your transpose function is being evaluated on a direct-mapped cache, conflict misses are a potential problem. Think about the potential for conflict misses in your code, especially along the diagonal. Try to think of access patterns that will decrease the number of these conflict misses.
 - Blocking is a useful technique for reducing cache misses. See http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdffor more information.
 - Because valgrind introduces many stack accesses that have nothing to do with your code, we have filtered out all stack accesses from the trace. This is why we have banned local arrays and placed limits on the number of local variables.

### 6.3 Putting it all Together
We have provided you with a driver program, called ./driver.py, that performs a complete evaluation of your simulator and transpose code. This is the same program your instructor uses to evaluate your handins. The driver uses test-csim to evaluate your simulator, and it uses test-trans to evaluate your submitted transpose function on the three matrix sizes. Then it prints a summary of your results and the points you have earned.
To run the driver, type:
linux> ./driver.py