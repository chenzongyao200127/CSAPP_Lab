若专注于命令行界面（CLI）的工具，用于逆向工程和反汇编，这里有一些推荐：

# GDB
https://solar1s.t0nkov.site/posts/summary_of_gdb_commands_for_x86-64_systems/

# objdump

`objdump` 是一个功能强大的程序，用于显示各种信息关于目标文件（如可执行文件或者对象文件）。它是 GNU 二进制实用工具（Binutils）的一部分，在 Linux 和其他 Unix-like 系统上广泛使用。以下是 `objdump` 的一些常见用法和具体命令：

### 查看反汇编代码

- **命令**：`objdump -d <binary>`
- **说明**：此命令用于查看二进制文件的反汇编代码。它会显示程序中每个函数的汇编代码。

### 查看全部信息

- **命令**：`objdump -x <binary>`
- **说明**：此命令显示目标文件的全部头部信息，包括节信息、符号表等。

### 查看特定节的内容

- **命令**：`objdump -s -j .text <binary>`
- **说明**：该命令用于查看指定节（如 `.text` 节）的内容。您可以替换 `.text` 为任何其他节的名称。

### 查看符号表

- **命令**：`objdump -t <binary>`
- **说明**：此命令用于显示目标文件的符号表，包括函数、变量等的地址和信息。

### 查看文件头部信息

- **命令**：`objdump -f <binary>`
- **说明**：该命令显示文件的头部信息，包括文件类型、架构、入口点地址等。

### 查看动态链接信息

- **命令**：`objdump -p <binary>`
- **说明**：用于显示动态链接的信息，包括所需的共享库等。

### 查看特定函数的汇编代码

- **命令**：`objdump -d <binary> --start-address=<address> --stop-address=<address>`
- **说明**：此命令用于查看从指定开始地址到停止地址之间的汇编代码。地址应该是函数或代码段的实际地址。

### 输出格式化的汇编代码

- **命令**：`objdump -D -M intel <binary>`
- **说明**：以 Intel 语法（而非默认的 AT&T 语法）输出整个文件的反汇编代码。

### 查看源代码与汇编混合输出

- **命令**：`objdump -S <binary>`
- **说明**：如果编译时带有调试信息（如使用 `-g` 选项），该命令将显示源代码与对应的汇编代码的混合输出。

### 实践提示

- 确保目标文件是用于您当前使用的架构编译的。不同架构的汇编语言有所不同。
- 对于大型二进制文件，输出可能非常长。考虑将输出重定向到文件中，例如：`objdump -d <binary> > disassembly.txt`。
- 熟悉汇编语言可以帮助您更好地理解 `objdump` 的输出。

`objdump` 是一个非常强大的工具，特别是当您需要深入了解程序的内部结构和行为时。通过实际的使用和实验，您可以更好地掌握它的各种功能。

====================================================================================================

在函数调用时，寄存器的行为遵循特定的调用约定，这取决于操作系统和体系结构。在x86-64架构中，使用的是System V AMD64 ABI调用约定（在大多数Unix-like系统中使用，如Linux和macOS）。在此约定中，寄存器的使用如下：

### Caller-Saved Registers (Caller)
这些寄存器在函数调用前由调用者（caller）负责保存（如果它们之后还需要使用）。
*如果被调用的函数（callee）打算使用这些寄存器，它必须先保存原始值，然后在返回之前恢复它们*。这些通常包括：

- **RAX, RCX, RDX, RSI, RDI, R8, R9, R10, R11**：这些通用寄存器在函数调用时不保留值。它们用于传递参数（前六个参数分别使用 RDI, RSI, RDX, RCX, R8, 和 R9）和存储返回值（RAX）。

### Callee-Saved Registers (Callee)
*被调用的函数负责保存和恢复这些寄存器的值。如果函数打算更改这些寄存器中的任何一个，它必须先将原始值保存到栈上，并在返回之前恢复它们*。这些包括：

- **RBX, RBP, R12, R13, R14, R15**：这些寄存器在函数调用中被保留，被调用的函数需要保存它们的原始值（如果它们被更改）。

### 特殊寄存器
- **RSP（栈指针）**：通常由操作系统或运行时环境管理，用于指向当前栈帧的顶部。
- **RIP（指令指针）**：存储下一条要执行的指令的地址。

### 函数调用过程
在函数调用时，通常发生以下步骤：
1. **参数传递**：调用者将参数放入寄存器（RDI, RSI, RDX, RCX, R8, R9）和/或栈上。
2. **调用指令**：使用`CALL`指令调用函数。这会将返回地址压入栈上并跳转到函数地址。
3. **栈帧设置**：被调用的函数通常会通过推入旧的基指针（RBP）并设置新的基指针来创建一个新的栈帧。
4. **保存寄存器**：如果函数打算更改任何callee-saved寄存器，它会先将它们的原始值保存到栈上。
5. **执行函数体**：执行函数的实际代码。
6. **恢复寄存器**：在函数返回之前，恢复在栈上保存的任何callee-saved寄存器的值。
7. **返回**：通过`RET`指令返回，这会从栈上弹出返回地址并跳转到该地址。

在处理寄存器时，遵循这些规则确保了函数能够在不干扰调用者的情况下运行，同时保留了必要的数据。


~~~shell
$rax        Return value
$rbx        Callee saved
$rcx        4th argument
$rdx        3rd argument
$rsi        2nd argument
$rdi        1st argument
$rbp        Callee saved
$rsp        Stack Pointer
$r8         5th argument
$r9         6th argument
$r10        Callee saved
$r11        Used fot linking
$r12        Unused for C
$r13        Callee saved
$r14        Callee saved
$r15        Callee saved 
~~~

这段文本描述了在x86-64架构下，各个通用寄存器在函数调用中的常规用途。每个寄存器根据系统V AMD64 ABI（应用二进制接口）有特定的角色和职责。以下是每个寄存器的详细解释：

1. **$rax**：返回值。用于存储函数的返回值。
2. **$rbx**：被调用者保存（Callee saved）。在函数调用期间，如果被修改，需要被原函数恢复原值。

3. **$rcx**：第四个参数。用于传递函数的第四个参数。

4. **$rdx**：第三个参数。用于传递函数的第三个参数。

5. **$rsi**：第二个参数。用于传递函数的第二个参数。

6. **$rdi**：第一个参数。用于传递函数的第一个参数。

7. **$rbp**：被调用者保存。通常用作基指针，指向当前函数栈帧的底部。

8. **$rsp**：栈指针。指向当前栈帧的顶部。

9. **$r8**：第五个参数。用于传递函数的第五个参数。

10. **$r9**：第六个参数。用于传递函数的第六个参数。

11. **$r10**：被调用者保存。尽管如此，它在函数调用中通常用于临时存储和计算。

12. **$r11**：用于链接。在某些函数调用和返回操作中使用，通常用于临时存储和计算。

13. **$r12**：通常在C语言中不直接使用，但被保留作为被调用者保存寄存器。

14. **$r13**：被调用者保存。在C语言中不常直接使用，但需要在函数调用中被保存。

15. **$r14**：被调用者保存。同$r13，不常在C中直接使用，但在函数调用中需要保存。

16. **$r15**：被调用者保存。与$r14类似，不常直接用于C，但在函数调用中需要被保存。

这种寄存器的使用规则有助于标准化函数调用和返回的过程，确保数据的一致性和程序的稳定性。在设计函数时，遵循这些规则可以提高代码的可移植性和兼容性。




### Callee-Saved 寄存器
- **定义**：Callee-saved 寄存器是在函数调用过程中，被调用的函数（即callee）负责保护其原始值的寄存器。如果这些寄存器在被调用的函数中被修改，那么在函数返回之前，这些寄存器必须恢复到它们被调用时的原始值。
- **目的**：这种机制允许调用函数（caller）在函数调用后继续使用这些寄存器中的值，无需担心这些值会因被调用的函数而改变。

### 示例
假设有两个函数，`FunctionA` 调用 `FunctionB`：
- 在 `FunctionA` 中，`rbx` 寄存器用于保存一个重要的值。
- `FunctionA` 调用 `FunctionB`。
- 如果 `FunctionB` 需要使用 `rbx` 寄存器，它首先需要将 `rbx` 的当前值保存到栈中。
- `FunctionB` 完成其任务后，必须从栈中恢复 `rbx` 的原始值，然后再返回到 `FunctionA`。
- `FunctionA` 继续执行时，可以安全地假定 `rbx` 的值没有改变。

### 重要性
- **保持数据完整性**：确保调用函数在调用其他函数后可以安全地继续使用其寄存器中的值。
- **提高代码可靠性**：遵循这些约定有助于编写更可靠、更容易维护的代码。

在编写汇编语言或理解底层程序行为时，理解这些约定是非常重要的。在高级语言编程中，这些细节通常由编译器自动处理。

想象一下，你在做一个复杂的数学问题，在纸上写下了很多计算过程和中间结果。突然，你的朋友来到你身边，请求你帮忙解答一个小问题。你决定暂停你的问题，把纸上的一块空白地方用来帮朋友计算。但为了不弄乱你自己的计算，你先把自己的中间结果记在脑子里或另外一张纸上。

帮完朋友后，你回到自己的问题。你从脑子里或那张纸上把自己之前的中间结果再写回原来的地方，然后继续你的计算。

在计算机的世界里，函数就像是在解决特定问题的人。每个函数在运行时都需要一些空间来存储它的信息，这就像是纸上的空间。这些信息包括了函数需要记住的数字（在计算机里我们称之为"寄存器"的内容）。

所以，当一个函数（比如你自己）需要暂停并去运行另一个函数（帮朋友解题），它会先保存它正在使用的寄存器的内容（你的中间结果），然后再开始运行那个新的函数。新函数运行完毕后，原来的函数会继续运行，并恢复之前保存的寄存器内容，就像你把记在脑子里或另外一张纸上的中间结果再写回原来的地方一样。

这样做的目的是为了保证每个函数都可以独立运行，不会干扰其他函数的运行。简而言之，就是每个函数都需要保持现场的整洁，以便它们可以无忧地开始和结束。


# Caller Saved
想象一下，你正在你的房间做手工艺项目。突然，你需要去厨房帮忙做一些事情。在你离开房间之前，你知道你的弟弟会进来玩，可能会动到你的东西。所以，为了保护你的项目，你决定把重要的东西收起来放在安全的地方。当你从厨房回来后，你再把这些东西拿出来，继续你的手工艺项目。

在这个例子中，你的房间就像是一个函数（我们称之为 "caller"，即函数调用者），而厨房是另一个函数（被称为 "callee"，即被调用的函数）。你需要在离开房间之前（即在调用另一个函数之前）保存一些重要的东西（这些就是 "caller-saved" 寄存器）。这是因为你不能保证在你离开的时候，这些东西不会被弟弟（或者在计算机的情境中，被其他函数）动到。

所以，"caller-saved" 寄存器是指在*调用另一个函数之前*，当前函数需要保存（并在返回后恢复）这些寄存器的值的责任。这是为了防止被调用的函数更改这些寄存器的值，从而影响到调用它的函数的运行。

总结一下，"caller-saved" 寄存器是那些在函数调用其他函数之前需要被保存的寄存器，以确保当原函数继续执行时，这些寄存器的值没有被意外改变。

# 总结
"callee-saved"（被调用者保存）和"caller-saved"（调用者保存）寄存器的主要区别在于何时保存它们的值，以及谁负责保存。

让我来进一步阐述这两者之间的区别：

### Callee-Saved 寄存器
- **何时保存**：当一个函数（callee）开始执行时，它需要保存这些寄存器的原始值（如果它打算使用或更改它们）。
- **谁负责**：被调用的函数（callee）负责保存和恢复这些寄存器的值。
- **目的**：确保调用者（caller）的环境在调用之后保持不变，即使被调用者更改了这些寄存器的值。

### Caller-Saved 寄存器
- **何时保存**：在调用另一个函数（callee）之前，当前的函数（caller）需要保存这些寄存器的值（如果它们包含重要信息且希望在调用之后使用）。
- **谁负责**：调用函数（caller）负责保存这些寄存器的值。
- **目的**：防止被调用的函数（callee）更改这些寄存器的值，从而影响调用者（caller）的后续执行。

### 总结
- **Callee-Saved**：被调用者在函数开始时保存，结束时恢复。
- **Caller-Saved**：调用者在调用其他函数之前保存，调用结束后恢复。

这种约定是为了保持程序执行的一致性和可预测性，特别是在多个函数相互调用的情况下。
在高级语言编程中，这些细节通常由编译器自动管理，但了解这些概念对于理解函数调用的底层机制很有帮助。

当然，我可以为您提供一个简化的ASCII示意图来展示caller-saved和callee-saved寄存器的概念。在这个示意图中，我们将展示一个函数（caller）如何调用另一个函数（callee），以及在这个过程中如何处理这两种类型的寄存器。

```
Caller Function           Callee Function
(调用者函数)              (被调用者函数)
+------------------+      +------------------+
| Caller-Saved Reg | ---> |                  |
| (保存寄存器)      |      |                   |
+------------------+      +------------------+
|                  |      | Callee-Saved Reg |
|                  | <--- | (保存寄存器)      |
+------------------+      +------------------+
|                  |      |                  |
|   Do Work        | ---> |   Do Work        |
|   (执行工作)      |      |   (执行工作)      |
|                  |      |                  |
+------------------+      +------------------+
| Restore Caller-  |      | Restore Callee-  |
| Saved Reg        | <--- | Saved Reg        |
| (恢复寄存器)       |      | (恢复寄存器)     |
+------------------+      +------------------+
| Continue Work    |      |                  |
| (继续工作)        |      |                  |
+------------------+      +------------------+
```

### 解释
- **Caller Function**：调用者函数在调用另一个函数之前，保存caller-saved寄存器的值。调用完成后，恢复这些寄存器的值，然后继续执行。
- **Callee Function**：被调用者函数在开始执行时，保存callee-saved寄存器的值。执行完成后，恢复这些寄存器的值，然后返回控制权给调用者函数。

这个示意图展示了函数调用过程中对不同类型寄存器的处理流程，以确保各自的数据不会被另一方的执行过程意外改变。

====================================================================================================
是的，在大多数情况下，寄存器的值是保存在栈上的。栈是一种特殊的内存结构，用于在函数调用期间存储局部变量、寄存器值以及返回地址。当涉及到保存寄存器值时，通常是将它们推入（push）到栈上，并在之后从栈上弹出（pop）以恢复它们。这个过程遵循“后进先出”（LIFO）的原则。

### 保存和恢复的顺序
1. **保存顺序**：
   - 当进入一个新的函数时（尤其是在准备调用另一个函数之前），caller-saved寄存器（如果它们包含了重要的数据）会被依次推入栈上。这通常发生在函数的开始部分。
   - 对于callee-saved寄存器，当一个函数（callee）打算使用这些寄存器时，它会在开始执行任何其他操作之前，先将这些寄存器的原始值推入栈上。

2. **恢复顺序**：
   - 对于callee-saved寄存器，被调用的函数（callee）在返回前会从栈上弹出这些寄存器的值，以恢复它们原始的状态。
   - 对于caller-saved寄存器，调用者（caller）在调用的函数返回后，需要从栈上弹出这些值以恢复它们的原始状态。

### 示例
假设我们有两个callee-saved寄存器（例如`rbx`和`rbp`）和两个caller-saved寄存器（例如`rax`和`rcx`），以下是保存和恢复的示例顺序：

```
保存寄存器到栈上：
push rbx    ; callee-saved
push rbp    ; callee-saved
push rax    ; caller-saved
push rcx    ; caller-saved

...执行函数的操作...

恢复寄存器从栈上：
pop rcx     ; caller-saved
pop rax     ; caller-saved
pop rbp     ; callee-saved
pop rbx     ; callee-saved
```

这种顺序确保了每个寄存器的值在使用后都被正确地恢复，从而保护了函数的执行环境不受其他函数调用的影响。在高级语言中，这个过程通常由编译器自动管理。